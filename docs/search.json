[
  {
    "objectID": "hodge_podge.html",
    "href": "hodge_podge.html",
    "title": "ST 558 Homework 6",
    "section": "",
    "text": "Task 1: Conceptual Questions\n\nThe purpose of the lapply() function is to apply a function to a list, and return a list. The equivalent in the purrr package is the map() function.\nlapply(X = my_list, FUN = cor, method = \"kendall\")\n\n\nmethod = \"kendall\" needs to be after defining FUN = cor, not within cor()\n\n\nTwo advantages of using the purrr package over base R are the helper functions included in purr and the general consistency it has.\nA side-effect function is a function does not automatically return a modified version of the data. Examples include print() and plot().\nYou can create a variable called sd within a function and not have it overwrite sd() from base R because R creates a separate environment for your functions, with the objects created within thr function only existing while the function is being run.\n\n\n\nTask 2 : Writing R Functions\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.2     ✔ tibble    3.3.0\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.1.0     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n#1. \n# define a function to return the root mean squared error, allow for the removal of NAs by included ellipses\ngetRMSE &lt;- function(responses, predictions, ...){\n  RMSE = sqrt(mean((responses - predictions)^2, ...))\n  RMSE\n}\n\n#2. \n# run code to create response values and predictions\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\n# test the getRMSE() function\ngetRMSE(responses = resp, predictions = pred)\n\n[1] 0.9581677\n\n# replace two of the response values with NA_real_\nresp_na &lt;- resp\nresp_na[51] = NA_real_\nresp_na[11] = NA_real_\n\n# test the getRMSE() function without specification to remove missing values\ngetRMSE(responses = resp_na, predictions = pred)\n\n[1] NA\n\n# test the getRMSE() function with specification to remove missing values\ngetRMSE(responses = resp_na, predictions = pred, na.rm = TRUE)\n\n[1] 0.9547445\n\n#. \n# define the MAE function\ngetMAE &lt;- function(responses, predictions, ...){\n  MAE &lt;- mean(abs(responses - predictions), ...)\n  MAE\n}\n\n#4. \n# create response and prediction values for MAE\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\n# test the getMAE() function\ngetMAE(responses = resp, predictions = pred)\n\n[1] 0.8155776\n\n# replace two of the response values with NA_real_\nresp_na &lt;- resp\nresp_na[51] = NA_real_\nresp_na[11] = NA_real_\n\n# test the getMAE() function without specification to remove missing values\ngetMAE(responses = resp_na, predictions = pred)\n\n[1] NA\n\n# test the getMAE() function with specification to remove missing values\ngetMAE(responses = resp_na, predictions = pred, na.rm = TRUE)\n\n[1] 0.8103637\n\n# 5\n# create a wrapper function to produce one or both of the RMSE and MAE, with values returned with appropriate names\nmetric_wrapper &lt;- function(resps, preds, metric = c(\"RMSE\", \"MAE\"), ...){\n  if(!is.vector(resps)){\n    stop(\"Error! 'resps' is not a vector.\")\n  }\n  if(!is.vector(preds)){\n    stop(\"Error! 'preds' is not a vector.\")\n  }\n  if(!is.atomic(resps)){\n    stop(\"Error! 'resps' is not atomic.\")\n  }\n  if(!is.atomic(preds)){\n    stop(\"Error! 'preds' is not atomic.\")\n  }\n  if(!is.numeric(resps)){\n    stop(\"Error! 'resps' is not numeric.\")\n  }\n  if(!is.numeric(preds)){\n    stop(\"Error! 'preds' is not numeric.\")\n  } # I did not combine the if statements so the user will know specifically what the issue with their inputs is\n  \n  # create an empty list to put your results in\n  results &lt;- list()\n  \n  # check if RMSE is in the metric, if it is, calculate it using getRMSE() and return it under the name RMSE\n  if (\"RMSE\" %in% metric) {\n    results$RMSE &lt;- getRMSE(resps, preds, ...)\n  }\n  \n  # check if MAE is in the metric, if it is, calculate it using getMAE() and return it under the name MAE\n  if (\"MAE\" %in% metric) {\n    results$MAE &lt;- getMAE(resps, preds, ...)\n  }\n  \n  # return the results as a vector by unlisting\n  return(unlist(results))\n}\n\n#6. \n# create response and prediction values for the wrapper function\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\n# test the wrapper function with defaults (both RMSE and MAE)\nmetric_wrapper(resps = resp, preds = pred)\n\n     RMSE       MAE \n0.9581677 0.8155776 \n\n# test the wrapper function only on RMSE\nmetric_wrapper(resps = resp, preds = pred, metric = \"RMSE\")\n\n     RMSE \n0.9581677 \n\n# test the wrapper function only on MAE\nmetric_wrapper(resps = resp, preds = pred, metric = \"MAE\")\n\n      MAE \n0.8155776 \n\n# replace two of the response values with NA_real_\nresp_na &lt;- resp\nresp_na[51] = NA_real_\nresp_na[11] = NA_real_\n\n# test the wrapper function without specification to remove missing values\nmetric_wrapper(resps = resp_na, preds = pred)\n\nRMSE  MAE \n  NA   NA \n\n# test the wrapper function with specification to remove missing values\nmetric_wrapper(resps = resp_na, preds = pred, na.rm = TRUE)\n\n     RMSE       MAE \n0.9547445 0.8103637 \n\n# test the wrapper function only on RMSE after adding missing values\nmetric_wrapper(resps = resp_na, preds = pred, metric = \"RMSE\", na.rm = TRUE)\n\n     RMSE \n0.9547445 \n\n# test the wrapper function only on MAE after adding missing values\nmetric_wrapper(resps = resp_na, preds = pred, metric = \"MAE\", na.rm = TRUE)\n\n      MAE \n0.8103637 \n\n# test the wrapper function while returning a non-vector for the response\nmetric_wrapper(resps = iris, preds = pred)\n\nError in metric_wrapper(resps = iris, preds = pred): Error! 'resps' is not a vector.\n\n\n\n\nTask 3 : Practice with purrr\n\n# linear model object\nlm_fit1 &lt;- lm(Sepal.Length ~ Sepal.Width + Species, data = iris)\n\n# 1. pull coefficients in three different ways\n# with $\nlm_fit1$coefficients\n\n      (Intercept)       Sepal.Width Speciesversicolor  Speciesvirginica \n        2.2513932         0.8035609         1.4587431         1.9468166 \n\n# with coef()\ncoef(lm_fit1)\n\n      (Intercept)       Sepal.Width Speciesversicolor  Speciesvirginica \n        2.2513932         0.8035609         1.4587431         1.9468166 \n\n# with pluck() from purrr\nlm_fit1 |&gt; \n  pluck(\"coefficients\")\n\n      (Intercept)       Sepal.Width Speciesversicolor  Speciesvirginica \n        2.2513932         0.8035609         1.4587431         1.9468166 \n\n# 2. fit different models and use map() and pluck() to get all the coefficients\nlm_fit2 &lt;- lm(Sepal.Length ~ Sepal.Width, data = iris)\nlm_fit3 &lt;- lm(Sepal.Length ~ Petal.Width + Sepal.Width + Species, data = iris)\nlm_fit4 &lt;- lm(Sepal.Length ~ Petal.Width + Petal.Length + Sepal.Width + Species,\ndata = iris)\nfits &lt;- list(lm_fit1, lm_fit2, lm_fit3, lm_fit4)\n\n# pull out all the coeffients\nmap(fits, pluck(\"coefficients\"))\n\n[[1]]\n      (Intercept)       Sepal.Width Speciesversicolor  Speciesvirginica \n        2.2513932         0.8035609         1.4587431         1.9468166 \n\n[[2]]\n(Intercept) Sepal.Width \n  6.5262226  -0.2233611 \n\n[[3]]\n      (Intercept)       Petal.Width       Sepal.Width Speciesversicolor \n        2.5210733         0.3715768         0.6982260         0.9881297 \n Speciesvirginica \n        1.2375878 \n\n[[4]]\n      (Intercept)       Petal.Width      Petal.Length       Sepal.Width \n        2.1712663        -0.3151552         0.8292439         0.4958889 \nSpeciesversicolor  Speciesvirginica \n       -0.7235620        -1.0234978 \n\n# 3. Use map() and confint() to get confidence intervals for all coefficients of all models in the list\nmap(fits, confint)\n\n[[1]]\n                      2.5 %   97.5 %\n(Intercept)       1.5206309 2.982156\nSepal.Width       0.5933983 1.013723\nSpeciesversicolor 1.2371791 1.680307\nSpeciesvirginica  1.7491525 2.144481\n\n[[2]]\n                2.5 %     97.5 %\n(Intercept)  5.579865 7.47258038\nSepal.Width -0.529820 0.08309785\n\n[[3]]\n                        2.5 %    97.5 %\n(Intercept)        1.74261803 3.2995285\nPetal.Width       -0.02042746 0.7635811\nSepal.Width        0.46205710 0.9343950\nSpeciesversicolor  0.44520784 1.5310516\nSpeciesvirginica   0.46412393 2.0110518\n\n[[4]]\n                       2.5 %      97.5 %\n(Intercept)        1.6182321  2.72430044\nPetal.Width       -0.6140049 -0.01630542\nPetal.Length       0.6937939  0.96469395\nSepal.Width        0.3257653  0.66601260\nSpeciesversicolor -1.1982739 -0.24885002\nSpeciesvirginica  -1.6831329 -0.36386273\n\n# 4. create histograms of the residuals for each model\n# set up 2x2 plotting window\npar(mfrow = c(2, 2))\n\n# create histogram with map(), walk() and hist\nfits |&gt; \n  map(pluck(\"residuals\")) |&gt; \n  walk(hist)\n\n\n\n\n\n\n\n# 5. redo part 4 with adding names via set_names() and changing walk() to iwalk(), using an anonymous function for the histogram\nfits |&gt; \n  map(pluck(\"residuals\")) |&gt; \n  set_names(\"fit1\", \"fit2\", \"fit3\", \"fit4\") |&gt; \n  iwalk(\\(x, idx) hist(x, main = idx))"
  }
]
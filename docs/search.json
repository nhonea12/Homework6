[
  {
    "objectID": "hodge_podge.html",
    "href": "hodge_podge.html",
    "title": "ST 558 Homework 6",
    "section": "",
    "text": "Task 1: Conceptual Questions\n\nThe purpose of the lapply() function is to apply a function to a list, and return a list. The equivalent in the purrr package is the map() function.\nlapply(X = my_list, FUN = cor, method = \"kendall\")\n\n\nmethod = \"kendall\" needs to be after defining FUN = cor, not within cor()\n\n\nTwo advantages of using the purrr package over base R are the helper functions included in purr and the general consistency it has.\nA side-effect function is a function does not automatically return a modified version of the data. Examples include print() and plot().\nYou can create a variable called sd within a function and not have it overwrite sd() from base R because R creates a separate environment for your functions, with the objects created within thr function only existing while the function is being run.\n\n\n\nTask 2 : Writing R Functions\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.2     ✔ tibble    3.3.0\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.1.0     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n#1. \n# define a function to return the root mean squared error, allow for the removal of NAs by included ellipses\ngetRMSE &lt;- function(responses, predictions, ...){\n  RMSE = sqrt(mean((responses - predictions)^2, ...))\n  RMSE\n}\n\n#2. \n# run code to create response values and predictions\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\n# test the getRMSE() function\ngetRMSE(responses = resp, predictions = pred)\n\n[1] 0.9581677\n\n# replace two of the response values with NA_real_\nresp_na &lt;- resp\nresp_na[51] = NA_real_\nresp_na[11] = NA_real_\n\n# test the getRMSE() function without specification to remove missing values\ngetRMSE(responses = resp_na, predictions = pred)\n\n[1] NA\n\n# test the getRMSE() function with specification to remove missing values\ngetRMSE(responses = resp_na, predictions = pred, na.rm = TRUE)\n\n[1] 0.9547445\n\n#. \n# define the MAE function\ngetMAE &lt;- function(responses, predictions, ...){\n  MAE &lt;- mean(abs(responses - predictions), ...)\n  MAE\n}\n\n#4. \n# create response and prediction values for MAE\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\n# test the getMAE() function\ngetMAE(responses = resp, predictions = pred)\n\n[1] 0.8155776\n\n# replace two of the response values with NA_real_\nresp_na &lt;- resp\nresp_na[51] = NA_real_\nresp_na[11] = NA_real_\n\n# test the getMAE() function without specification to remove missing values\ngetMAE(responses = resp_na, predictions = pred)\n\n[1] NA\n\n# test the getMAE() function with specification to remove missing values\ngetMAE(responses = resp_na, predictions = pred, na.rm = TRUE)\n\n[1] 0.8103637\n\n# 5\n# create a wrapper function to produce one or both of the RMSE and MAE, with values returned with appropriate names\nmetric_wrapper &lt;- function(resps, preds, metric = c(\"RMSE\", \"MAE\"), ...){\n  if(!is.vector(resps)){\n    stop(\"Error! 'resps' is not a vector.\")\n  }\n  if(!is.vector(preds)){\n    stop(\"Error! 'preds' is not a vector.\")\n  }\n  if(!is.atomic(resps)){\n    stop(\"Error! 'resps' is not atomic.\")\n  }\n  if(!is.atomic(preds)){\n    stop(\"Error! 'preds' is not atomic.\")\n  }\n  if(!is.numeric(resps)){\n    stop(\"Error! 'resps' is not numeric.\")\n  }\n  if(!is.numeric(preds)){\n    stop(\"Error! 'preds' is not numeric.\")\n  } # I did not combine the if statements so the user will know specifically what the issue with their inputs is\n  \n  # create an empty list to put your results in\n  results &lt;- list()\n  \n  # check if RMSE is in the metric, if it is, calculate it using getRMSE() and return it under the name RMSE\n  if (\"RMSE\" %in% metric) {\n    results$RMSE &lt;- getRMSE(resps, preds, ...)\n  }\n  \n  # check if MAE is in the metric, if it is, calculate it using getMAE() and return it under the name MAE\n  if (\"MAE\" %in% metric) {\n    results$MAE &lt;- getMAE(resps, preds, ...)\n  }\n  \n  # return the results as a vector by unlisting\n  return(unlist(results))\n}\n\n#6. \n# create response and prediction values for the wrapper function\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\n# test the wrapper function with defaults (both RMSE and MAE)\nmetric_wrapper(resps = resp, preds = pred)\n\n     RMSE       MAE \n0.9581677 0.8155776 \n\n# test the wrapper function only on RMSE\nmetric_wrapper(resps = resp, preds = pred, metric = \"RMSE\")\n\n     RMSE \n0.9581677 \n\n# test the wrapper function only on MAE\nmetric_wrapper(resps = resp, preds = pred, metric = \"MAE\")\n\n      MAE \n0.8155776 \n\n# replace two of the response values with NA_real_\nresp_na &lt;- resp\nresp_na[51] = NA_real_\nresp_na[11] = NA_real_\n\n# test the wrapper function without specification to remove missing values\nmetric_wrapper(resps = resp_na, preds = pred)\n\nRMSE  MAE \n  NA   NA \n\n# test the wrapper function with specification to remove missing values\nmetric_wrapper(resps = resp_na, preds = pred, na.rm = TRUE)\n\n     RMSE       MAE \n0.9547445 0.8103637 \n\n# test the wrapper function only on RMSE after adding missing values\nmetric_wrapper(resps = resp_na, preds = pred, metric = \"RMSE\", na.rm = TRUE)\n\n     RMSE \n0.9547445 \n\n# test the wrapper function only on MAE after adding missing values\nmetric_wrapper(resps = resp_na, preds = pred, metric = \"MAE\", na.rm = TRUE)\n\n      MAE \n0.8103637 \n\n# test the wrapper function while returning a non-vector for the response\nmetric_wrapper(resps = iris, preds = pred)\n\nError in metric_wrapper(resps = iris, preds = pred): Error! 'resps' is not a vector.\n\n\n\n\nTask 3 : Practice with purrr"
  }
]